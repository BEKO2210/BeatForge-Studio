---
phase: 09-effects
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/effects/types.ts
  - src/effects/cameraShake.ts
  - src/effects/vignette.ts
  - src/effects/index.ts
  - src/hooks/useCameraShake.ts
  - src/visualizers/VisualizerContainer.tsx
autonomous: true

must_haves:
  truths:
    - "Canvas visually shakes on strong beats"
    - "Vignette darkens edges of canvas at all times"
    - "Camera shake intensity scales with beat intensity"
    - "Effects feel cinematic, not jarring"
  artifacts:
    - path: "src/effects/cameraShake.ts"
      provides: "Camera shake calculation function"
      exports: ["getCameraShakeOffset"]
    - path: "src/effects/vignette.ts"
      provides: "Vignette rendering function"
      exports: ["renderVignette"]
    - path: "src/hooks/useCameraShake.ts"
      provides: "React hook for camera shake animation"
      exports: ["useCameraShake"]
  key_links:
    - from: "src/visualizers/VisualizerContainer.tsx"
      to: "src/hooks/useCameraShake.ts"
      via: "Hook integration"
      pattern: "useCameraShake"
    - from: "src/visualizers/VisualizerContainer.tsx"
      to: "src/effects/vignette.ts"
      via: "Render callback"
      pattern: "renderVignette"
---

<objective>
Implement camera shake and vignette post-processing effects for cinematic beat-reactive visuals.

Purpose: Add visual punch on strong beats (camera shake) and cinematic depth (vignette) to elevate the visualizer quality.
Output: Camera shake hook, vignette renderer, integrated into VisualizerContainer.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-beat-reactivity/06-02-SUMMARY.md

@src/renderer/Renderer.ts
@src/hooks/useBeatReaction.ts
@src/animation/easing.ts
@src/visualizers/VisualizerContainer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create effects types and camera shake function</name>
  <files>src/effects/types.ts, src/effects/cameraShake.ts, src/effects/index.ts</files>
  <action>
    Create effect system foundation:

    1. **src/effects/types.ts**: Define EffectsConfig interface with:
       - cameraShake: { enabled: boolean, maxOffset: number, decayMs: number }
       - vignette: { enabled: boolean, intensity: number, softness: number }

    2. **src/effects/cameraShake.ts**: Pure function getCameraShakeOffset():
       - Input: (reaction: number, maxOffset: number) where reaction is 0-1
       - Output: { x: number, y: number } pixel offset
       - Use random direction with reaction-scaled magnitude
       - Use Perlin-like smoothed random (not pure noise - too jarring)
       - Simple approach: sin/cos with time-based angle + reaction magnitude

    3. **src/effects/index.ts**: Barrel export

    Camera shake algorithm:
    ```
    const angle = (performance.now() / 50) % (Math.PI * 2); // Slow rotation
    const magnitude = reaction * maxOffset;
    return {
      x: Math.cos(angle) * magnitude * (0.5 + Math.random() * 0.5),
      y: Math.sin(angle) * magnitude * (0.5 + Math.random() * 0.5)
    };
    ```

    This creates smooth shake with randomness, not pure noise.
  </action>
  <verify>npm run build succeeds, types are exported correctly</verify>
  <done>EffectsConfig type and getCameraShakeOffset function exported from src/effects</done>
</task>

<task type="auto">
  <name>Task 2: Create useCameraShake hook and vignette renderer</name>
  <files>src/hooks/useCameraShake.ts, src/effects/vignette.ts</files>
  <action>
    1. **src/hooks/useCameraShake.ts**: React hook similar to useBeatReaction pattern:
       - Input: (isBeat: boolean, intensity: number, options?: { maxOffset?: number, decayMs?: number })
       - Returns: { offsetX: number, offsetY: number, isActive: boolean }
       - Use 100ms decay (faster than visualizers for snappy feel)
       - Trigger on strong beats only (intensity > 0.6 threshold)
       - Call getCameraShakeOffset each frame during decay

    2. **src/effects/vignette.ts**: Pure render function:
       - renderVignette(ctx: CanvasRenderingContext2D, width: number, height: number, config: VignetteConfig)
       - Draw radial gradient from center (transparent) to edges (dark)
       - intensity controls edge darkness (0-1)
       - softness controls gradient spread (0.3 = starts at 30% from center)

       Gradient stops:
       - 0% radius: rgba(0,0,0,0)
       - softness%: rgba(0,0,0,0)
       - 100%: rgba(0,0,0, intensity)

    Default config: intensity=0.4, softness=0.5
  </action>
  <verify>npm run build succeeds, both exports work</verify>
  <done>useCameraShake hook and renderVignette function ready for integration</done>
</task>

<task type="auto">
  <name>Task 3: Integrate effects into VisualizerContainer</name>
  <files>src/visualizers/VisualizerContainer.tsx, src/effects/index.ts</files>
  <action>
    Integrate camera shake and vignette into VisualizerContainer:

    1. Add effects state:
       ```tsx
       const [effectsEnabled, setEffectsEnabled] = useState(true);
       ```

    2. Use camera shake hook:
       ```tsx
       const { offsetX, offsetY } = useCameraShake(
         beatInfo?.isBeat ?? false,
         beatInfo?.intensity ?? 0,
         { maxOffset: 8, decayMs: 100 }
       );
       ```

    3. Apply shake via canvas transform:
       - Register a pre-render callback that applies ctx.translate(offsetX, offsetY)
       - Or pass offset to Renderer which applies before all other callbacks

       Better approach: Pass shake offset as props to VisualizerContainer's render logic.
       Since Renderer uses save/restore, apply shake at the container level by:
       - Adding a new render callback at layer 'background' (priority -10) that just does translate
       - All subsequent callbacks inherit the transform

       Actually simpler: Modify the canvas wrapper div style:
       ```tsx
       <div
         className="visualizer-canvas-wrapper"
         style={{ transform: `translate(${offsetX}px, ${offsetY}px)` }}
       >
       ```
       This shakes the entire canvas without modifying render callbacks.

    4. Add vignette render callback:
       - Register at layer 'overlay' (priority 20, after visualizers, before text)
       - Call renderVignette(ctx, width, height, { intensity: 0.35, softness: 0.5 })

    5. Add effects toggle button to selector (optional but nice):
       ```tsx
       <button
         className={`visualizer-selector-btn ${effectsEnabled ? 'active' : ''}`}
         onClick={() => setEffectsEnabled(!effectsEnabled)}
       >
         FX
       </button>
       ```

    Ensure effects feel cinematic not jarring:
    - Camera shake only on strong beats (>0.6 intensity)
    - Max offset of 8px (subtle but noticeable)
    - Vignette at 35% intensity (noticeable but not heavy)
  </action>
  <verify>npm run dev - load audio, play, verify shake on strong beats and vignette visible at edges</verify>
  <done>Camera shake and vignette effects integrated, toggle available, visual verification passed</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds without errors
- [ ] npm run lint passes (or only pre-existing warnings)
- [ ] Camera shake triggers on strong beats (visible canvas movement)
- [ ] Vignette is visible at canvas edges (dark gradient)
- [ ] Effects don't cause jank or performance issues at 60 FPS
- [ ] Effects toggle works (FX button)
</verification>

<success_criteria>

- All tasks completed
- Camera shake feels punchy on beats, not nauseating
- Vignette adds cinematic depth without being distracting
- Effects integrate cleanly with existing visualizer system
- No regressions in visualizer or text rendering
</success_criteria>

<output>
After completion, create `.planning/phases/09-effects/09-01-SUMMARY.md`
</output>
