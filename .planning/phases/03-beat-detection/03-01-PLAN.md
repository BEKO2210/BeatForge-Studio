---
phase: 03-beat-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/audio/types.ts
  - src/audio/BeatDetector.ts
  - src/audio/AudioEngine.ts
autonomous: true

must_haves:
  truths:
    - "AnalyserNode receives audio signal during playback"
    - "Frequency data updates every frame at 60 FPS"
    - "Beat events fire when energy threshold exceeded"
    - "Frequency bands (bass, mid, treble) are calculated per frame"
  artifacts:
    - path: "src/audio/BeatDetector.ts"
      provides: "Beat detection with frequency analysis"
      min_lines: 100
      exports: ["BeatDetector"]
    - path: "src/audio/types.ts"
      provides: "Beat detection types"
      contains: "FrequencyBands"
  key_links:
    - from: "src/audio/BeatDetector.ts"
      to: "src/audio/AudioEngine.ts"
      via: "AnalyserNode connection"
      pattern: "getAnalyserNode"
---

<objective>
Implement core beat detection using Web Audio AnalyserNode with frequency band analysis and beat event emission.

Purpose: Provide real-time audio analysis data that visualizers can react to - the foundation of beat-reactive visuals.
Output: BeatDetector class integrated with AudioEngine, emitting beat events and frequency data at 60 FPS.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audio-engine/02-01-SUMMARY.md

@src/audio/AudioEngine.ts
@src/audio/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AnalyserNode to AudioEngine</name>
  <files>src/audio/AudioEngine.ts</files>
  <action>
Modify AudioEngine to create and expose an AnalyserNode for frequency analysis:

1. Add private `analyserNode: AnalyserNode | null = null` property
2. In `initAudioContext()`, create AnalyserNode with optimal settings:
   - `fftSize: 2048` (good balance of frequency resolution and performance)
   - `smoothingTimeConstant: 0.8` (smooth transitions, reduce jitter)
3. Route audio through AnalyserNode: source → analyser → gain → destination
4. Add public method `getAnalyserNode(): AnalyserNode | null` to expose for BeatDetector
5. Ensure AnalyserNode is cleaned up in `dispose()`

The routing must be: sourceNode → analyserNode → gainNode → destination
This ensures the AnalyserNode receives the audio signal for analysis.
  </action>
  <verify>TypeScript compiles: npm run build</verify>
  <done>AudioEngine exposes getAnalyserNode() and routes audio through it</done>
</task>

<task type="auto">
  <name>Task 2: Create BeatDetector class with frequency analysis</name>
  <files>src/audio/types.ts, src/audio/BeatDetector.ts</files>
  <action>
1. Add types to src/audio/types.ts:
```typescript
export interface FrequencyBands {
  bass: number;      // 20-250 Hz - normalized 0-1
  mid: number;       // 250-2000 Hz - normalized 0-1
  treble: number;    // 2000-20000 Hz - normalized 0-1
  overall: number;   // Average energy - normalized 0-1
}

export interface BeatInfo {
  isBeat: boolean;           // True if beat detected this frame
  intensity: number;         // Beat intensity 0-1
  frequencyBands: FrequencyBands;
  timeSinceLastBeat: number; // Milliseconds since last beat
}

export type BeatCallback = (beatInfo: BeatInfo) => void;
```

2. Create src/audio/BeatDetector.ts:
```typescript
export class BeatDetector {
  private analyser: AnalyserNode;
  private frequencyData: Uint8Array;
  private lastBeatTime: number = 0;
  private energyHistory: number[] = [];
  private readonly historySize = 43; // ~700ms at 60fps
  private readonly beatThreshold = 1.3; // Energy must be 1.3x average
  private readonly beatCooldown = 100; // Min ms between beats

  constructor(analyserNode: AnalyserNode)

  // Returns current frequency bands (call each frame)
  getFrequencyBands(): FrequencyBands

  // Returns full beat info including beat detection (call each frame)
  getBeatInfo(): BeatInfo

  // Register callback for beat events
  onBeat(callback: BeatCallback): () => void  // Returns unsubscribe function

  // Reset state (call when seeking or loading new track)
  reset(): void
}
```

Beat detection algorithm (energy-based):
1. Get frequency data from AnalyserNode.getByteFrequencyData()
2. Calculate bass energy (bins 0-10 for 20-250Hz range with fftSize 2048, sampleRate 44100)
3. Bass is primary beat indicator - compare to rolling average
4. If current bass > (average * beatThreshold) AND cooldown passed → beat detected
5. Track energy history for adaptive threshold

Frequency band calculation:
- Bass: bins 0-10 (~20-250Hz)
- Mid: bins 10-93 (~250-2000Hz)
- Treble: bins 93-512 (~2000-20000Hz)
- Bin calculation: binIndex = (frequency * fftSize) / sampleRate

IMPORTANT: Normalize all values to 0-1 range (divide by 255 for Uint8Array data)
  </action>
  <verify>npm run build succeeds with no type errors</verify>
  <done>BeatDetector class created with getFrequencyBands(), getBeatInfo(), onBeat() methods</done>
</task>

<task type="auto">
  <name>Task 3: Create analysis loop integration</name>
  <files>src/audio/types.ts, src/audio/AudioEngine.ts</files>
  <action>
Extend AudioEngine to support beat detection callbacks:

1. Add to AudioEngineCallbacks in types.ts:
```typescript
export interface AudioEngineCallbacks {
  // ... existing callbacks
  /** Called each frame with beat analysis data */
  onBeatInfo?: (beatInfo: BeatInfo) => void;
}
```

2. Add BeatDetector integration to AudioEngine:
- Add private `beatDetector: BeatDetector | null = null` property
- After AnalyserNode is created in initAudioContext(), create BeatDetector
- In startTimeUpdateLoop(), also call beatDetector.getBeatInfo() and emit via onBeatInfo callback
- In dispose(), set beatDetector to null
- Add method `getBeatDetector(): BeatDetector | null` for direct access

3. Ensure the analysis loop runs at 60 FPS (it already uses requestAnimationFrame):
```typescript
private startTimeUpdateLoop(): void {
  const updateTime = () => {
    if (this.state === 'playing') {
      const currentTime = this.getCurrentTime();
      this.callbacks.onTimeUpdate?.(currentTime);

      // Beat detection
      if (this.beatDetector) {
        const beatInfo = this.beatDetector.getBeatInfo();
        this.callbacks.onBeatInfo?.(beatInfo);
      }

      this.animationFrameId = requestAnimationFrame(updateTime);
    }
  };
  this.animationFrameId = requestAnimationFrame(updateTime);
}
```

4. On seek or load, call beatDetector.reset() to clear history
  </action>
  <verify>npm run build succeeds, npm run lint passes</verify>
  <done>AudioEngine emits onBeatInfo callback every frame during playback</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run lint` passes (or only has pre-existing warnings)
- [ ] AudioEngine.getAnalyserNode() returns AnalyserNode when audio is loaded
- [ ] AudioEngine.getBeatDetector() returns BeatDetector instance
- [ ] BeatDetector.getFrequencyBands() returns normalized 0-1 values
- [ ] BeatDetector.getBeatInfo().isBeat toggles based on audio energy
</verification>

<success_criteria>
- All tasks completed
- AudioEngine routes audio through AnalyserNode
- BeatDetector analyzes frequency data and detects beats
- onBeatInfo callback fires every frame during playback
- No TypeScript errors, lint passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-beat-detection/03-01-SUMMARY.md`
</output>
