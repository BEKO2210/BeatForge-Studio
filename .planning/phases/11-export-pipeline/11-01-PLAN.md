---
phase: 11-export-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/export/types.ts
  - src/export/VideoExporter.ts
  - src/export/index.ts
  - src/audio/AudioEngine.ts
autonomous: true

must_haves:
  truths:
    - "VideoExporter can capture canvas as video stream"
    - "Audio is captured alongside video during recording"
    - "Export produces playable WebM file with synced audio-video"
  artifacts:
    - path: "src/export/VideoExporter.ts"
      provides: "Video export orchestration using MediaRecorder"
      min_lines: 80
      exports: ["VideoExporter"]
    - path: "src/export/types.ts"
      provides: "Export types and resolution definitions"
      exports: ["ExportState", "ExportResolution", "ExportOptions"]
  key_links:
    - from: "VideoExporter.ts"
      to: "canvas.captureStream()"
      via: "getVideoStream method"
      pattern: "captureStream"
    - from: "AudioEngine.ts"
      to: "MediaStreamAudioDestinationNode"
      via: "createExportDestination method"
      pattern: "createMediaStreamDestination"
---

<objective>
Create the export infrastructure for capturing canvas + audio as WebM video.

Purpose: Enable video export by providing VideoExporter class that orchestrates MediaRecorder capture of canvas visuals synchronized with audio playback.

Output: VideoExporter class, export types, and AudioEngine modification for audio capture routing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audio-engine/02-01-SUMMARY.md

@src/audio/AudioEngine.ts
@src/renderer/Renderer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create export types and resolution definitions</name>
  <files>src/export/types.ts, src/export/index.ts</files>
  <action>
Create export type definitions:

**src/export/types.ts:**
- ExportState type: 'idle' | 'preparing' | 'recording' | 'encoding' | 'complete' | 'error'
- ExportResolution type with id, label, width, height (e.g., '720p', '1080p')
- EXPORT_RESOLUTIONS constant array with 720p (1280x720) and 1080p (1920x1080)
- ExportOptions interface: { resolution: ExportResolution, frameRate?: number }
- ExportProgress interface: { state: ExportState, progress: number (0-1), error?: string }
- ExportCallbacks interface: { onProgress?: (progress: ExportProgress) => void, onComplete?: (blob: Blob) => void }

**src/export/index.ts:**
- Export all types from types.ts
- Export VideoExporter (placeholder import, will be created in Task 2)

Use consistent patterns from existing types files (audio/types.ts, renderer/types.ts).
  </action>
  <verify>npm run lint -- src/export/ passes with no errors</verify>
  <done>Export types defined and exported</done>
</task>

<task type="auto">
  <name>Task 2: Add audio export routing to AudioEngine</name>
  <files>src/audio/AudioEngine.ts</files>
  <action>
Add method to AudioEngine for creating audio capture stream:

1. Add private property: `private mediaStreamDest: MediaStreamAudioDestinationNode | null = null;`

2. Add public method `createExportDestination(): MediaStream`:
   - Initialize AudioContext if needed
   - Create MediaStreamAudioDestinationNode: `this.audioContext.createMediaStreamDestination()`
   - Connect gainNode to mediaStreamDest (in parallel with destination)
   - Return mediaStreamDest.stream

3. Add public method `disconnectExportDestination(): void`:
   - If mediaStreamDest exists, disconnect from gainNode
   - Set mediaStreamDest to null

4. Update dispose() to also clean up mediaStreamDest

The routing during export becomes:
source → analyser → gain → [destination (for speakers) + mediaStreamDest (for recording)]

This allows audio to play while also being captured for export.
  </action>
  <verify>npm run build succeeds with no TypeScript errors</verify>
  <done>AudioEngine can create audio stream for export capture</done>
</task>

<task type="auto">
  <name>Task 3: Create VideoExporter class</name>
  <files>src/export/VideoExporter.ts</files>
  <action>
Create VideoExporter class that orchestrates canvas + audio recording:

**Constructor:**
- Takes canvas: HTMLCanvasElement, audioEngine: AudioEngine, callbacks: ExportCallbacks

**Private properties:**
- mediaRecorder: MediaRecorder | null
- recordedChunks: Blob[]
- state: ExportState
- startTime: number (for progress calculation)
- duration: number (total audio duration)

**Public methods:**

1. `async start(options: ExportOptions): Promise<void>`
   - Validate canvas and audioEngine are ready
   - Set state to 'preparing', emit progress
   - Get video stream: `canvas.captureStream(options.frameRate ?? 30)`
   - Get audio stream: `audioEngine.createExportDestination()`
   - Combine streams: Create new MediaStream with video tracks + audio tracks
   - Create MediaRecorder with combined stream, mimeType 'video/webm;codecs=vp9,opus'
   - Set up ondataavailable to push chunks
   - Set up onstop to handle completion
   - Set state to 'recording', emit progress
   - Start recording: mediaRecorder.start(100) (100ms chunks)
   - Start audio playback from beginning: audioEngine.seek(0), audioEngine.play()

2. `stop(): void`
   - If recording, stop mediaRecorder
   - Pause audioEngine
   - Disconnect export destination

3. `getState(): ExportState`

**Private methods:**

1. `handleDataAvailable(event: BlobEvent): void`
   - Push event.data to recordedChunks if size > 0

2. `handleStop(): void`
   - Set state to 'encoding'
   - Create final blob from chunks: `new Blob(recordedChunks, { type: 'video/webm' })`
   - Clean up export destination
   - Set state to 'complete'
   - Emit onComplete with blob

3. `emitProgress(): void`
   - Calculate progress based on audioEngine.getCurrentTime() / duration
   - Call onProgress callback

Use error handling: wrap operations in try-catch, set state to 'error' on failure.
  </action>
  <verify>npm run build succeeds, npm run lint passes</verify>
  <done>VideoExporter class captures canvas and audio into WebM blob</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run lint` passes for src/export/
- [ ] Export types are properly exported from src/export/index.ts
- [ ] AudioEngine has createExportDestination and disconnectExportDestination methods
- [ ] VideoExporter exports are available from src/export/
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript or lint errors
- Export infrastructure ready for UI integration
</success_criteria>

<output>
After completion, create `.planning/phases/11-export-pipeline/11-01-SUMMARY.md`
</output>
