---
phase: 07-text-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/text/types.ts
  - src/text/TextRenderer.ts
  - src/text/animations.ts
  - src/text/index.ts
autonomous: true

must_haves:
  truths:
    - "TextLayer type defines all required properties (content, position, font, animation)"
    - "TextRenderer draws text on canvas with correct styling"
    - "Animation functions produce eased values for fade/slide/scale"
  artifacts:
    - path: "src/text/types.ts"
      provides: "TextLayer interface, TextAnimation type, TextStyle type"
      exports: ["TextLayer", "TextAnimation", "TextStyle", "TextPosition"]
    - path: "src/text/TextRenderer.ts"
      provides: "Canvas text rendering with styling"
      exports: ["renderTextLayer"]
    - path: "src/text/animations.ts"
      provides: "Animation calculations for text effects"
      exports: ["calculateTextAnimation", "TextAnimationState"]
  key_links:
    - from: "src/text/TextRenderer.ts"
      to: "src/text/types.ts"
      via: "imports TextLayer, TextStyle"
      pattern: "import.*from.*types"
    - from: "src/text/animations.ts"
      to: "src/text/types.ts"
      via: "imports TextAnimation"
      pattern: "import.*TextAnimation.*from.*types"
---

<objective>
Build the text system foundation: types, rendering, and animations.

Purpose: Establish the core infrastructure that text components will use to render styled, animated text on the canvas.
Output: Type definitions, text rendering function, and animation utilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow:
@src/visualizers/types.ts
@src/renderer/Renderer.ts
@src/hooks/useBeatReaction.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create text type definitions</name>
  <files>src/text/types.ts</files>
  <action>
Create TypeScript types for the text system:

1. TextPosition interface:
   - x: number (0-1 normalized, 0=left, 1=right)
   - y: number (0-1 normalized, 0=top, 1=bottom)
   - anchor: 'left' | 'center' | 'right' (text alignment anchor)

2. TextStyle interface:
   - fontFamily: string (default 'Inter, system-ui, sans-serif')
   - fontSize: number (in pixels, default 32)
   - fontWeight: 'normal' | 'bold' | number
   - color: string (CSS color, default '#ffffff')
   - strokeColor?: string (optional outline color)
   - strokeWidth?: number (outline width in pixels)
   - shadow?: { color: string; blur: number; offsetX: number; offsetY: number }

3. TextAnimation type (union):
   - 'none' | 'fade' | 'slide-up' | 'slide-down' | 'slide-left' | 'slide-right' | 'scale' | 'pulse'

4. TextLayer interface:
   - id: string (unique identifier)
   - content: string (the text to display)
   - position: TextPosition
   - style: TextStyle
   - animation: TextAnimation
   - beatReactive: boolean (whether to pulse on beats)
   - visible: boolean

Export all types.
  </action>
  <verify>tsc --noEmit passes with no errors</verify>
  <done>All text types exported and type-check correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create text rendering function</name>
  <files>src/text/TextRenderer.ts</files>
  <action>
Create a function to render a TextLayer on canvas:

1. Export function `renderTextLayer(ctx: CanvasRenderingContext2D, layer: TextLayer, canvasWidth: number, canvasHeight: number, animationState?: TextAnimationState): void`

2. Implementation:
   - Skip if layer.visible is false
   - Calculate actual pixel position from normalized (0-1) coordinates:
     - actualX = layer.position.x * canvasWidth
     - actualY = layer.position.y * canvasHeight
   - Apply animation offset if animationState provided (will be calculated by animations.ts)
   - Set font: `ctx.font = "${layer.style.fontWeight} ${layer.style.fontSize}px ${layer.style.fontFamily}"`
   - Set textAlign based on anchor: 'left' | 'center' | 'right'
   - Set textBaseline to 'middle' for consistent vertical centering
   - Apply globalAlpha if animation has opacity value
   - Apply transform if animation has scale value
   - If strokeColor and strokeWidth set, draw stroke first:
     - ctx.strokeStyle = strokeColor
     - ctx.lineWidth = strokeWidth
     - ctx.strokeText(content, x, y)
   - If shadow configured:
     - Set ctx.shadowColor, ctx.shadowBlur, ctx.shadowOffsetX, ctx.shadowOffsetY
   - Draw fill text:
     - ctx.fillStyle = layer.style.color
     - ctx.fillText(layer.content, x, y)
   - Restore globalAlpha and transform after drawing

Follow the pattern from visualizers: pure function, no side effects beyond canvas drawing.
  </action>
  <verify>tsc --noEmit passes</verify>
  <done>renderTextLayer function renders styled text at correct position</done>
</task>

<task type="auto">
  <name>Task 3: Create text animation utilities</name>
  <files>src/text/animations.ts, src/text/index.ts</files>
  <action>
Create animation calculation utilities in animations.ts:

1. Export interface TextAnimationState:
   - opacity: number (0-1)
   - offsetX: number (pixels)
   - offsetY: number (pixels)
   - scale: number (1 = normal)

2. Export function `calculateTextAnimation(animation: TextAnimation, progress: number, beatReaction: number): TextAnimationState`
   - progress: 0-1 (0 = start, 1 = fully visible)
   - beatReaction: 0-1 from useBeatReaction hook

3. Animation implementations:
   - 'none': { opacity: 1, offsetX: 0, offsetY: 0, scale: 1 }
   - 'fade': { opacity: easeOutQuad(progress), offsetX: 0, offsetY: 0, scale: 1 }
   - 'slide-up': { opacity: 1, offsetX: 0, offsetY: (1 - easeOutExpo(progress)) * 50, scale: 1 }
   - 'slide-down': { opacity: 1, offsetX: 0, offsetY: -(1 - easeOutExpo(progress)) * 50, scale: 1 }
   - 'slide-left': { opacity: 1, offsetX: (1 - easeOutExpo(progress)) * 50, offsetY: 0, scale: 1 }
   - 'slide-right': { opacity: 1, offsetX: -(1 - easeOutExpo(progress)) * 50, offsetY: 0, scale: 1 }
   - 'scale': { opacity: 1, offsetX: 0, offsetY: 0, scale: easeOutBack(progress) }
   - 'pulse': { opacity: 1, offsetX: 0, offsetY: 0, scale: 1 + beatReaction * 0.1 }

4. Easing functions (local to file):
   - easeOutQuad(t) = t * (2 - t)
   - easeOutExpo(t) = t === 1 ? 1 : 1 - Math.pow(2, -10 * t)
   - easeOutBack(t) = 1 + 2.70158 * Math.pow(t - 1, 3) + 1.70158 * Math.pow(t - 1, 2)

5. Create src/text/index.ts barrel file:
   - Export all from './types'
   - Export all from './TextRenderer'
   - Export all from './animations'
  </action>
  <verify>tsc --noEmit passes</verify>
  <done>Animation utilities calculate correct animation state values</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] All three files exist with correct exports
- [ ] Types are properly imported in TextRenderer and animations
- [ ] No circular dependencies
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Text infrastructure ready for component layer
- Types are well-documented with JSDoc comments
</success_criteria>

<output>
After completion, create `.planning/phases/07-text-system/07-01-SUMMARY.md`
</output>
